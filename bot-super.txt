#!/usr/bin/env python3
"""
Final Discord VPS Bot (Nextcord) - bot-super-final.py

This is the integrated final file combining requested features:
- Manual Points on /plan-add
- /admin-list, /admin-add, /admin-remove
- Claim, Manage UI with Start/Stop/Restart/Stats/SSH/Change Password/Reinstall/Backup/Restore
- /delete-vps (admin & owner)
- Backup snapshot rotation (3 max)
- /upgrade-my-vps (user upgrade via plan selection)
- Anti-miner basic detection (best-effort periodic checks)
- /development-mode on/off (owner only)
- /system-status (owner only)
- /announce (owner only)
- Purge system: /purge (owner), /non-purge (admin+owner), /purge-remove (admin+owner)
- VPS IDs auto-increment vps-1, vps-2...
- Hostname convention root@vps-1 stored in entry
- Many operations are best-effort and require pylxd on host

NOTE: This file uses best-effort LXD operations and file-based JSON storage.
"""

import os
import json
import uuid
import asyncio
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List

import nextcord
from nextcord import Interaction, Embed, SlashOption
from nextcord.ext import commands, tasks
from nextcord.ui import Modal, TextInput, Button, View, Select

from dotenv import load_dotenv

# attempt to import pylxd; if not available we'll gracefully degrade
try:
    import pylxd
    PYLXD_AVAILABLE = True
except Exception:
    PYLXD_AVAILABLE = False

load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN", "YOUR_TOKEN_HERE")
OWNER_ID = int(os.getenv("OWNER_ID")) if os.getenv("OWNER_ID") else None
BOT_LOGO_URL = os.getenv("BOT_LOGO_URL", "")

DATA_DIR = "./"
USERS_FILE = os.path.join(DATA_DIR, "users.json")
PLANS_FILE = os.path.join(DATA_DIR, "plans.json")
VPS_FILE = os.path.join(DATA_DIR, "vps.json")
ADMINS_FILE = os.path.join(DATA_DIR, "admins.json")
INVITES_FILE = os.path.join(DATA_DIR, "invites.json")
META_FILE = os.path.join(DATA_DIR, "meta.json")  # store vps counter, dev mode, purge safe list

intents = nextcord.Intents.default()
intents.members = True
intents.guilds = True
intents.messages = True

bot = commands.Bot(intents=intents, command_prefix="!")

file_lock = asyncio.Lock()

async def ensure_json_files():
    defaults = {
        USERS_FILE: {},
        PLANS_FILE: {},
        VPS_FILE: {},
        ADMINS_FILE: {"admins": []},
        INVITES_FILE: {},
        META_FILE: {"vps_counter": 0, "development_mode": False, "purge_safe": []}
    }
    for path, default in defaults.items():
        if not os.path.exists(path):
            with open(path, "w", encoding="utf-8") as f:
                json.dump(default, f, indent=4)

async def read_json(path: str) -> Any:
    async with file_lock:
        try:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return {}

async def write_json(path: str, data: Any):
    async with file_lock:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, default=str)

# Points helpers
async def get_user_points(user_id: int) -> int:
    users = await read_json(USERS_FILE)
    return int(users.get(str(user_id), {}).get("points", 0))

async def add_user_points(user_id: int, delta: int):
    users = await read_json(USERS_FILE)
    u = users.get(str(user_id), {})
    u["points"] = int(u.get("points", 0)) + int(delta)
    users[str(user_id)] = u
    await write_json(USERS_FILE, users)

# Admin helpers
async def is_admin(user_id: int) -> bool:
    if OWNER_ID and user_id == OWNER_ID:
        return True
    admins = await read_json(ADMINS_FILE)
    return str(user_id) in [str(x) for x in admins.get("admins", [])]

async def add_admin(user_id: int):
    admins = await read_json(ADMINS_FILE)
    cur = admins.get("admins", [])
    if str(user_id) not in [str(x) for x in cur]:
        cur.append(int(user_id))
        admins["admins"] = cur
        await write_json(ADMINS_FILE, admins)

async def remove_admin(user_id: int):
    admins = await read_json(ADMINS_FILE)
    cur = [int(x) for x in admins.get("admins", [])]
    if user_id in cur:
        cur.remove(user_id)
        admins["admins"] = cur
        await write_json(ADMINS_FILE, admins)

# Meta helpers
async def get_next_vps_id() -> str:
    meta = await read_json(META_FILE)
    counter = int(meta.get("vps_counter", 0)) + 1
    meta["vps_counter"] = counter
    await write_json(META_FILE, meta)
    return f"vps-{counter}"

async def dev_mode_enabled() -> bool:
    meta = await read_json(META_FILE)
    return bool(meta.get("development_mode", False))

async def set_dev_mode(enabled: bool):
    meta = await read_json(META_FILE)
    meta["development_mode"] = bool(enabled)
    await write_json(META_FILE, meta)

async def get_purge_safe_list() -> List[str]:
    meta = await read_json(META_FILE)
    return meta.get("purge_safe", [])

async def add_purge_safe(vps_id: str):
    meta = await read_json(META_FILE)
    arr = meta.get("purge_safe", [])
    if vps_id not in arr:
        arr.append(vps_id)
        meta["purge_safe"] = arr
        await write_json(META_FILE, meta)

async def remove_purge_safe(vps_id: str):
    meta = await read_json(META_FILE)
    arr = meta.get("purge_safe", [])
    if vps_id in arr:
        arr.remove(vps_id)
        meta["purge_safe"] = arr
        await write_json(META_FILE, meta)

# LXD manager (best-effort)
class LXDManager:
    def __init__(self):
        self.client = None
        if PYLXD_AVAILABLE:
            try:
                self.client = pylxd.Client()
            except Exception:
                self.client = None

    def available(self) -> bool:
        return self.client is not None

    def create_container(self, name: str, image_alias: str, cpu: int, ram_gb: int, disk_gb: int, root_password: str):
        if not self.available():
            return {"success": False, "error": "LXD unavailable"}
        config = {"name": name, "source": {"type": "image", "alias": image_alias}, "config": {}, "devices": {}}
        try:
            cont = self.client.containers.create(config, wait=True)
            cont.start(wait=True)
            try:
                cont.execute(["sh", "-lc", f"echo 'root:{root_password}' | chpasswd"], environment=None)
            except Exception:
                pass
            return {"success": True, "container_name": cont.name}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def delete(self, name: str):
        if not self.available():
            return {"success": False, "error": "LXD unavailable"}
        try:
            cont = self.client.containers.get(name)
            if cont.status.lower() == "running":
                cont.stop(wait=True)
            cont.delete(wait=True)
            return {"success": True}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def stop(self, name: str):
        if not self.available():
            return {"success": False, "error": "LXD unavailable"}
        try:
            cont = self.client.containers.get(name)
            cont.stop(wait=True)
            return {"success": True}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def start(self, name: str):
        if not self.available():
            return {"success": False, "error": "LXD unavailable"}
        try:
            cont = self.client.containers.get(name)
            cont.start(wait=True)
            return {"success": True}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def restart(self, name: str):
        if not self.available():
            return {"success": False, "error": "LXD unavailable"}
        try:
            cont = self.client.containers.get(name)
            cont.restart(wait=True)
            return {"success": True}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def stats(self, name: str):
        if not self.available():
            return {"success": False, "error": "LXD unavailable"}
        try:
            cont = self.client.containers.get(name)
            st = cont.state()
            return {"success": True, "memory": st.memory, "cpu": st.cpu, "status": cont.status}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def snapshot(self, name: str, snap_name: str):
        if not self.available():
            return {"success": False, "error": "LXD unavailable"}
        try:
            cont = self.client.containers.get(name)
            cont.snapshot.create(snap_name, wait=True)
            return {"success": True}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def list_snapshots(self, name: str):
        if not self.available():
            return {"success": False, "error": "LXD unavailable"}
        try:
            cont = self.client.containers.get(name)
            snaps = [s.name for s in cont.snapshots.all()]
            return {"success": True, "snapshots": snaps}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def restore_snapshot(self, name: str, snap_name: str):
        if not self.available():
            return {"success": False, "error": "LXD unavailable"}
        try:
            cont = self.client.containers.get(name)
            cont.stop(wait=True)
            cont.restore(snapshot=snap_name, stateful=False, wait=True)
            cont.start(wait=True)
            return {"success": True}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def set_root_password(self, name: str, new_pass: str):
        if not self.available():
            return {"success": False, "error": "LXD unavailable"}
        try:
            cont = self.client.containers.get(name)
            if cont.status.lower() != "running":
                try:
                    cont.start(wait=True)
                except Exception:
                    pass
            cont.execute(["sh", "-lc", f"echo 'root:{new_pass}' | chpasswd"], environment=None)
            return {"success": True}
        except Exception as e:
            return {"success": False, "error": str(e)}

lxd = LXDManager()

# Invite cache (for points)
invites_cache: Dict[int, Dict[str, int]] = {}

async def populate_invites_cache():
    invites_cache.clear()
    for g in bot.guilds:
        try:
            invs = await g.invites()
            invites_cache[g.id] = {i.code: i.uses for i in invs}
        except Exception:
            invites_cache[g.id] = {}

# --------------------
# UI Components
# --------------------

class PlanAddModal(Modal):
    def __init__(self, *, title: str = "Add VPS Plan"):
        super().__init__(title=title)
        self.name = TextInput(label="Plan Name", max_length=50)
        self.cpu = TextInput(label="CPU cores (int)", max_length=4)
        self.ram = TextInput(label="RAM (GB)", max_length=4)
        self.disk = TextInput(label="Disk (GB)", max_length=6)
        self.points = TextInput(label="Points Required (int)", max_length=8)
        self.description = TextInput(label="Description", style=nextcord.TextInputStyle.paragraph, max_length=500)
        self.add_item(self.name); self.add_item(self.cpu); self.add_item(self.ram)
        self.add_item(self.disk); self.add_item(self.points); self.add_item(self.description)

    async def callback(self, interaction: Interaction):
        if OWNER_ID and interaction.user.id != OWNER_ID:
            await interaction.response.send_message("Only the bot owner can add plans.", ephemeral=True)
            return
        try:
            cpu = int(self.cpu.value); ram = int(self.ram.value); disk = int(self.disk.value); points = int(self.points.value)
        except Exception:
            await interaction.response.send_message("CPU/RAM/Disk/Points must be integers.", ephemeral=True)
            return
        plan = {"name": self.name.value, "cpu": cpu, "ram": ram, "disk": disk, "points_required": points, "description": self.description.value, "created_at": datetime.utcnow().isoformat()}
        plans = await read_json(PLANS_FILE); pid = str(uuid.uuid4())[:8]; plans[pid] = plan; await write_json(PLANS_FILE, plans)
        embed = Embed(title="Plan Added", description=f"{plan['name']} (ID: {pid})", color=0x00FF00); embed.set_footer(text="Made by GG!")
        await interaction.response.send_message(embed=embed, ephemeral=True)

class ClaimPasswordModal(Modal):
    def __init__(self, plan_id: str, os_choice: str):
        super().__init__(title="Enter root password")
        self.plan_id = plan_id; self.os_choice = os_choice
        self.password = TextInput(label="Root password", min_length=6, max_length=128)
        self.add_item(self.password)

    async def callback(self, interaction: Interaction):
        user_id = interaction.user.id
        plans = await read_json(PLANS_FILE)
        if self.plan_id not in plans:
            await interaction.response.send_message("Plan not found.", ephemeral=True); return
        plan = plans[self.plan_id]; required = int(plan.get("points_required", 0))
        user_points = await get_user_points(user_id)
        if user_points < required:
            await interaction.response.send_message(f"You need {required} points but have {user_points}.", ephemeral=True); return
        await add_user_points(user_id, -required)
        vps_id = await get_next_vps_id()
        cont_name = vps_id  # use vps-1 as container name
        image_alias = "ubuntu/22.04" if "ubuntu" in self.os_choice.lower() else "debian/11"
        tm_link = f"https://tmate.io/t/{vps_id}"
        vps_entry = {"vps_id": vps_id, "owner_id": user_id, "plan_id": self.plan_id, "os": self.os_choice, "password": self.password.value, "container_name": cont_name, "tm_link": tm_link, "status": "creating", "created_at": datetime.utcnow().isoformat(), "suspended": False, "suspended_at": None, "backups": []}
        vps_all = await read_json(VPS_FILE); vps_all[vps_id] = vps_entry; await write_json(VPS_FILE, vps_all)
        create_res = None
        if lxd.available():
            try:
                create_res = lxd.create_container(name=cont_name, image_alias=image_alias, cpu=plan.get("cpu",1), ram_gb=plan.get("ram",1), disk_gb=plan.get("disk",10), root_password=self.password.value)
            except Exception as e:
                create_res = {"success": False, "error": str(e)}
        else:
            create_res = {"success": False, "error": "LXD not available; recorded entry only"}
        if create_res.get("success"):
            vps_entry["status"] = "running"; vps_entry["container_name"] = create_res.get("container_name", cont_name); await write_json(VPS_FILE, vps_all)
            await interaction.response.send_message(embed=Embed(title="VPS Created", description=f"{vps_id} created.", color=0x00FF00))
        else:
            vps_entry["status"] = "failed"; vps_entry["create_error"] = create_res.get("error"); await write_json(VPS_FILE, vps_all)
            await interaction.response.send_message(embed=Embed(title="VPS Recorded", description=f"{vps_id} recorded but creation failed: {vps_entry.get('create_error')}", color=0xFFAA00))

class ChangePasswordModal(Modal):
    def __init__(self, vps_id: str):
        super().__init__(title="Change root password")
        self.vps_id = vps_id
        self.new_password = TextInput(label="New password", min_length=6, max_length=128)
        self.add_item(self.new_password)
    async def callback(self, interaction: Interaction):
        vps_all = await read_json(VPS_FILE); v = vps_all.get(self.vps_id)
        if not v: await interaction.response.send_message("VPS not found.", ephemeral=True); return
        if int(v.get("owner_id")) != interaction.user.id and not await is_admin(interaction.user.id) and interaction.user.id != OWNER_ID:
            await interaction.response.send_message("Not permitted.", ephemeral=True); return
        v["password"] = self.new_password.value; await write_json(VPS_FILE, vps_all)
        if lxd.available():
            res = lxd.set_root_password(v.get("container_name"), self.new_password.value)
            if not res.get("success"):
                await interaction.response.send_message("Password updated in DB but failed inside container.", ephemeral=True); return
        await interaction.response.send_message("Password updated.", ephemeral=True)

class ReinstallModal(Modal):
    def __init__(self, vps_id: str):
        super().__init__(title="Reinstall VPS (Type YES)")
        self.vps_id=vps_id
        self.os_choice = TextInput(label="OS (Ubuntu/Debian)", max_length=20)
        self.new_pass = TextInput(label="New root password", min_length=6, max_length=128)
        self.confirm = TextInput(label="Type YES to confirm", max_length=5)
        self.add_item(self.os_choice); self.add_item(self.new_pass); self.add_item(self.confirm)
    async def callback(self, interaction: Interaction):
        vps_all = await read_json(VPS_FILE); v = vps_all.get(self.vps_id)
        if not v: await interaction.response.send_message("VPS not found.", ephemeral=True); return
        if int(v.get("owner_id")) != interaction.user.id and not await is_admin(interaction.user.id) and interaction.user.id != OWNER_ID:
            await interaction.response.send_message("Not permitted.", ephemeral=True); return
        if self.confirm.value.strip().upper() != "YES": await interaction.response.send_message("Confirmation missing. Cancelled.", ephemeral=True); return
        os_choice = self.os_choice.value.strip().lower(); image_alias = "ubuntu/22.04" if "ubuntu" in os_choice else "debian/11"
        cont_name = v.get("container_name"); new_pass = self.new_pass.value
        created = {"success": False, "error": "LXD unavailable"}
        if lxd.available():
            try:
                lxd.delete(cont_name)
            except Exception:
                pass
            plan = (await read_json(PLANS_FILE)).get(v.get("plan_id"), {})
            created = lxd.create_container(name=cont_name, image_alias=image_alias, cpu=plan.get("cpu",1), ram_gb=plan.get("ram",1), disk_gb=plan.get("disk",10), root_password=new_pass)
        v["os"] = os_choice; v["password"] = new_pass
        if created.get("success"):
            v["status"] = "running"; await write_json(VPS_FILE, vps_all); await interaction.response.send_message("Reinstall complete.", ephemeral=True)
        else:
            v["status"] = "failed"; v["create_error"] = created.get("error"); await write_json(VPS_FILE, vps_all); await interaction.response.send_message("Reinstall recorded but creation failed.", ephemeral=True)

class BackupModal(Modal):
    def __init__(self, vps_id: str):
        super().__init__(title="Create Backup (Confirm)")
        self.vps_id = vps_id
        self.confirm = TextInput(label="Type YES to confirm backup", max_length=5)
        self.add_item(self.confirm)
    async def callback(self, interaction: Interaction):
        if self.confirm.value.strip().upper() != "YES": await interaction.response.send_message("Cancelled.", ephemeral=True); return
        vps_all = await read_json(VPS_FILE); v = vps_all.get(self.vps_id)
        if not v: await interaction.response.send_message("VPS not found.", ephemeral=True); return
        if int(v.get("owner_id")) != interaction.user.id and not await is_admin(interaction.user.id) and interaction.user.id != OWNER_ID:
            await interaction.response.send_message("Not permitted.", ephemeral=True); return
        snap_name = f"backup-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}"
        res = {"success": False, "error": "LXD unavailable"}
        if lxd.available():
            res = lxd.snapshot(v.get("container_name"), snap_name)
        if res.get("success"):
            v_backups = v.get("backups", []); v_backups.append(snap_name)
            while len(v_backups) > 3:
                oldest = v_backups.pop(0)
                # best-effort: snapshot deletion omitted for simplicity
            v["backups"] = v_backups; await write_json(VPS_FILE, vps_all); await interaction.response.send_message("Backup created.", ephemeral=True)
        else:
            await interaction.response.send_message(f"Backup failed: {res.get('error')}", ephemeral=True)

class RestoreModal(Modal):
    def __init__(self, vps_id: str):
        super().__init__(title="Restore Backup (Type YES)")
        self.vps_id = vps_id
        self.snap = TextInput(label="Snapshot name to restore", placeholder="backup-2025...")
        self.confirm = TextInput(label="Type YES to confirm", max_length=5)
        self.add_item(self.snap); self.add_item(self.confirm)
    async def callback(self, interaction: Interaction):
        if self.confirm.value.strip().upper() != "YES": await interaction.response.send_message("Cancelled.", ephemeral=True); return
        vps_all = await read_json(VPS_FILE); v = vps_all.get(self.vps_id)
        if not v: await interaction.response.send_message("VPS not found.", ephemeral=True); return
        if int(v.get("owner_id")) != interaction.user.id and not await is_admin(interaction.user.id) and interaction.user.id != OWNER_ID:
            await interaction.response.send_message("Not permitted.", ephemeral=True); return
        snap_name = self.snap.value.strip()
        res = {"success": False, "error": "LXD unavailable"}
        if lxd.available():
            res = lxd.restore_snapshot(v.get("container_name"), snap_name)
        if res.get("success"):
            await interaction.response.send_message("Restore initiated.", ephemeral=True)
        else:
            await interaction.response.send_message(f"Restore failed: {res.get('error')}", ephemeral=True)

class ClaimSelectView(View):
    def __init__(self, user: nextcord.User, timeout: Optional[float]=120):
        super().__init__(timeout=timeout); self.user=user; self.selected_plan=None; self.selected_os=None

    @nextcord.ui.select(placeholder="Select a plan", min_values=1, max_values=1, custom_id="claim_plan_select")
    async def plan_select(self, select: Select, interaction: Interaction):
        if interaction.user.id != self.user.id: await interaction.response.send_message("Not your session.", ephemeral=True); return
        self.selected_plan = select.values[0]
        if self.selected_os: await interaction.response.send_modal(ClaimPasswordModal(self.selected_plan, self.selected_os))
        else: await interaction.response.send_message("Plan selected. Now choose OS.", ephemeral=True)

    @nextcord.ui.select(placeholder="Select OS", min_values=1, max_values=1, custom_id="claim_os_select",
                         options=[nextcord.SelectOption(label="Ubuntu", value="Ubuntu"), nextcord.SelectOption(label="Debian", value="Debian")])
    async def os_select(self, select: Select, interaction: Interaction):
        if interaction.user.id != self.user.id: await interaction.response.send_message("Not your session.", ephemeral=True); return
        self.selected_os = select.values[0]
        if self.selected_plan: await interaction.response.send_modal(ClaimPasswordModal(self.selected_plan, self.selected_os))
        else: await interaction.response.send_message("OS selected. Now choose Plan.", ephemeral=True)

class ManageView(View):
    def __init__(self, vps_id: str, owner: nextcord.User, timeout: Optional[float]=120):
        super().__init__(timeout=timeout); self.vps_id=vps_id; self.owner=owner

    @nextcord.ui.button(style=nextcord.ButtonStyle.green, label="Start", custom_id="btn_start")
    async def start(self, button: Button, interaction: Interaction):
        if interaction.user.id != self.owner.id: await interaction.response.send_message("Not allowed.", ephemeral=True); return
        vps = await read_json(VPS_FILE); v = vps.get(self.vps_id)
        if not v: await interaction.response.send_message("VPS not found.", ephemeral=True); return
        if lxd.available():
            res = lxd.start(v.get("container_name"))
            if res.get("success"): v["status"]="running"; await write_json(VPS_FILE, vps); await interaction.response.send_message("Started.", ephemeral=True)
            else: await interaction.response.send_message(f"Start failed: {res.get('error')}", ephemeral=True)
        else: await interaction.response.send_message("LXD unavailable.", ephemeral=True)

    @nextcord.ui.button(style=nextcord.ButtonStyle.danger, label="Stop", custom_id="btn_stop")
    async def stop(self, button: Button, interaction: Interaction):
        if interaction.user.id != self.owner.id: await interaction.response.send_message("Not allowed.", ephemeral=True); return
        vps = await read_json(VPS_FILE); v = vps.get(self.vps_id)
        if not v: await interaction.response.send_message("VPS not found.", ephemeral=True); return
        if lxd.available():
            res = lxd.stop(v.get("container_name"))
            if res.get("success"): v["status"]="stopped"; await write_json(VPS_FILE, vps); await interaction.response.send_message("Stopped.", ephemeral=True)
            else: await interaction.response.send_message(f"Stop failed: {res.get('error')}", ephemeral=True)
        else: await interaction.response.send_message("LXD unavailable.", ephemeral=True)

    @nextcord.ui.button(style=nextcord.ButtonStyle.secondary, label="Restart", custom_id="btn_restart")
    async def restart(self, button: Button, interaction: Interaction):
        if interaction.user.id != self.owner.id: await interaction.response.send_message("Not allowed.", ephemeral=True); return
        vps = await read_json(VPS_FILE); v = vps.get(self.vps_id)
        if not v: await interaction.response.send_message("VPS not found.", ephemeral=True); return
        if lxd.available():
            res = lxd.restart(v.get("container_name"))
            if res.get("success"): v["status"]="running"; await write_json(VPS_FILE, vps); await interaction.response.send_message("Restarted.", ephemeral=True)
            else: await interaction.response.send_message(f"Restart failed: {res.get('error')}", ephemeral=True)
        else: await interaction.response.send_message("LXD unavailable.", ephemeral=True)

    @nextcord.ui.button(style=nextcord.ButtonStyle.blurple, label="Stats", custom_id="btn_stats")
    async def stats(self, button: Button, interaction: Interaction):
        if interaction.user.id != self.owner.id: await interaction.response.send_message("Not allowed.", ephemeral=True); return
        vps = await read_json(VPS_FILE); v = vps.get(self.vps_id)
        if not v: await interaction.response.send_message("VPS not found.", ephemeral=True); return
        if lxd.available():
            res = lxd.stats(v.get("container_name"))
            if res.get("success"):
                embed = Embed(title=f"Stats {self.vps_id}"); embed.add_field(name="Status", value=res.get("status")); embed.add_field(name="Memory", value=str(res.get("memory"))); embed.add_field(name="CPU", value=str(res.get("cpu"))); await interaction.response.send_message(embed=embed, ephemeral=True)
            else: await interaction.response.send_message(f"Stats failed: {res.get('error')}", ephemeral=True)
        else: await interaction.response.send_message("LXD unavailable.", ephemeral=True)

    @nextcord.ui.button(style=nextcord.ButtonStyle.url, label="SSH (tmate)", custom_id="btn_ssh", url="https://example.invalid")
    async def ssh(self, button: Button, interaction: Interaction):
        # URL button replaced on creation time
        await interaction.response.send_message("Use the SSH (tmate) URL button shown.", ephemeral=True)

    @nextcord.ui.button(style=nextcord.ButtonStyle.gray, label="Change Password", custom_id="btn_change")
    async def change(self, button: Button, interaction: Interaction):
        if interaction.user.id != self.owner.id: await interaction.response.send_message("Not allowed.", ephemeral=True); return
        modal = ChangePasswordModal(self.vps_id); await interaction.response.send_modal(modal)

    @nextcord.ui.button(style=nextcord.ButtonStyle.red, label="Reinstall (Wipe)", custom_id="btn_reinstall")
    async def reinstall(self, button: Button, interaction: Interaction):
        if interaction.user.id != self.owner.id: await interaction.response.send_message("Not allowed.", ephemeral=True); return
        modal = ReinstallModal(self.vps_id); await interaction.response.send_modal(modal)

    @nextcord.ui.button(style=nextcord.ButtonStyle.green, label="Backup", custom_id="btn_backup")
    async def backup(self, button: Button, interaction: Interaction):
        if interaction.user.id != self.owner.id: await interaction.response.send_message("Not allowed.", ephemeral=True); return
        modal = BackupModal(self.vps_id); await interaction.response.send_modal(modal)

    @nextcord.ui.button(style=nextcord.ButtonStyle.gray, label="Restore", custom_id="btn_restore")
    async def restore(self, button: Button, interaction: Interaction):
        if interaction.user.id != self.owner.id: await interaction.response.send_message("Not allowed.", ephemeral=True); return
        modal = RestoreModal(self.vps_id); await interaction.response.send_modal(modal)

# --------------------
# Background tasks
# --------------------
statuses = [("Watching TOTALSERVER", nextcord.ActivityType.watching), ("Powering SnowCloud", nextcord.ActivityType.playing), ("Made by GG!", nextcord.ActivityType.playing)]
status_index = 0

@tasks.loop(seconds=5.0)
async def change_status():
    global status_index
    try:
        name, type_ = statuses[status_index % len(statuses)]
        await bot.change_presence(activity=nextcord.Activity(type=type_, name=name))
        status_index += 1
    except Exception:
        pass

@tasks.loop(seconds=30.0)
async def suspend_monitor():
    vps_all = await read_json(VPS_FILE); plans = await read_json(PLANS_FILE); users = await read_json(USERS_FILE)
    for vid, v in list(vps_all.items()):
        try:
            owner_id = int(v.get("owner_id"))
        except Exception:
            continue
        plan = plans.get(v.get("plan_id"))
        if not plan: continue
        required = int(plan.get("points_required", 0)); owner_points = int(users.get(str(owner_id), {}).get("points", 0))
        suspended = v.get("suspended", False); suspended_at = v.get("suspended_at")
        if owner_points < required and not suspended:
            cont = v.get("container_name")
            if lxd.available():
                try: lxd.stop(cont)
                except Exception: pass
            v["suspended"] = True; v["suspended_at"] = datetime.utcnow().isoformat(); v["status"]="suspended"; await write_json(VPS_FILE, vps_all)
            try:
                user = await bot.fetch_user(owner_id); await user.send(f"Your VPS {vid} suspended: points {owner_points} < required {required}. You have 1 hour to restore.") 
            except Exception: pass
        elif suspended and suspended_at:
            try:
                stime = datetime.fromisoformat(suspended_at)
                if datetime.utcnow() - stime > timedelta(hours=1):
                    cont = v.get("container_name")
                    if lxd.available():
                        try: lxd.delete(cont)
                        except Exception: pass
                    del vps_all[vid]; await write_json(VPS_FILE, vps_all)
                    try: user = await bot.fetch_user(owner_id); await user.send(f"Your VPS {vid} deleted after suspension.") 
                    except Exception: pass
            except Exception:
                pass

@tasks.loop(seconds=60.0)
async def anti_miner_scan():
    # Simple heuristic: check CPU usage via lxd stats and suspend if >95% for a container for extended time.
    if not lxd.available(): return
    vps_all = await read_json(VPS_FILE)
    for vid, v in vps_all.items():
        cont = v.get("container_name")
        try:
            res = lxd.stats(cont)
            if res.get("success"):
                cpu = res.get("cpu", {})
                try:
                    usage = 0
                    if isinstance(cpu, dict):
                        for k in ["usage", "user", "system"]:
                            if k in cpu:
                                try:
                                    usage = max(usage, float(cpu.get(k, 0)))
                                except Exception:
                                    pass
                    else:
                        usage = float(cpu)
                    if usage > 95:
                        v["suspended"] = True; v["suspended_at"] = datetime.utcnow().isoformat(); v["status"]="suspended"; await write_json(VPS_FILE, vps_all)
                        try: user = await bot.fetch_user(int(v.get("owner_id"))); await user.send(f"Your VPS {vid} suspended due to high CPU usage (possible miner).")
                        except Exception: pass
                except Exception:
                    pass
        except Exception:
            pass

# --------------------
# Events
# --------------------
@bot.event
async def on_ready():
    await ensure_json_files(); await populate_invites_cache()
    try: await bot.sync_application_commands()
    except Exception: pass
    print(f"Bot ready as {bot.user} (ID: {bot.user.id})")
    change_status.start(); suspend_monitor.start(); anti_miner_scan.start()

@bot.event
async def on_guild_join(guild):
    try:
        invs = await guild.invites(); invites_cache[guild.id] = {i.code: i.uses for i in invs}
    except Exception:
        invites_cache[guild.id] = {}

@bot.event
async def on_member_join(member):
    g = member.guild
    try: new_invs = await g.invites()
    except Exception: new_invs = []
    prev = invites_cache.get(g.id, {}); used_inviter=None
    for inv in new_invs:
        prev_uses = prev.get(inv.code, 0)
        if inv.uses > prev_uses: used_inviter = inv.inviter; break
    invites_cache[g.id] = {inv.code: inv.uses for inv in new_invs}
    if used_inviter:
        await add_user_points(used_inviter.id, 1)
        invs = await read_json(INVITES_FILE); invs[str(used_inviter.id)] = invs.get(str(used_inviter.id), 0) + 1; await write_json(INVITES_FILE, invs)
        try: await used_inviter.send(f"You gained +1 point because {member} joined using your invite.")
        except Exception: pass

# --------------------
# Slash commands
# --------------------
@bot.slash_command(name="plan-add", description="Owner: Add a VPS plan (manual points)")
async def plan_add(interaction: Interaction):
    if OWNER_ID and interaction.user.id != OWNER_ID: await interaction.response.send_message("Only owner.", ephemeral=True); return
    modal = PlanAddModal(); await interaction.response.send_modal(modal)

@bot.slash_command(name="plans", description="List plans")
async def plans_cmd(interaction: Interaction):
    plans = await read_json(PLANS_FILE)
    if not plans: await interaction.response.send_message("No plans.", ephemeral=True); return
    embed = Embed(title="Plans", color=0x00AAFF); embed.set_thumbnail(url=BOT_LOGO_URL)
    for pid,p in plans.items():
        embed.add_field(name=f"{p.get('name')} — ID: {pid}", value=f"CPU:{p.get('cpu')} | RAM:{p.get('ram')}GB | Disk:{p.get('disk')}GB\nPoints:{p.get('points_required')}\n{p.get('description')}", inline=False)
    await interaction.response.send_message(embed=embed, ephemeral=True)

@bot.slash_command(name="claim-vps", description="Claim a VPS plan")
async def claim_vps(interaction: Interaction):
    plans = await read_json(PLANS_FILE)
    if not plans: await interaction.response.send_message("No plans.", ephemeral=True); return
    view = ClaimSelectView(user=interaction.user)
    options = []
    for pid,p in plans.items():
        label = f"{p.get('name')} ({p.get('cpu')}c/{p.get('ram')}GB/{p.get('disk')}GB)"
        desc = f"Points: {p.get('points_required')}"
        options.append(nextcord.SelectOption(label=label, value=pid, description=str(desc)[:100]))
    for child in view.children:
        if isinstance(child, nextcord.ui.Select) and getattr(child, "custom_id", "") == "claim_plan_select":
            child.options = options
    await interaction.response.send_message("Select plan and OS:", view=view, ephemeral=True)

@bot.slash_command(name="manage", description="Manage your VPSes")
async def manage_cmd(interaction: Interaction):
    vps_all = await read_json(VPS_FILE); user_vps = [v for v in vps_all.values() if int(v.get("owner_id")) == interaction.user.id]
    if not user_vps: await interaction.response.send_message("No VPSes.", ephemeral=True); return
    options = []
    for v in user_vps:
        vid = v.get("vps_id"); status = v.get("status", "unknown"); label = f"{vid} ({status})"; options.append(nextcord.SelectOption(label=label, value=vid))
    class VPSSelect(View):
        @nextcord.ui.select(placeholder="Select VPS", min_values=1, max_values=1)
        async def sel(self, select: Select, interaction2: Interaction):
            if interaction2.user.id != interaction.user.id: await interaction2.response.send_message("Not your session.", ephemeral=True); return
            vid = select.values[0]; vps_all2 = await read_json(VPS_FILE); v = vps_all2.get(vid)
            if not v: await interaction2.response.send_message("VPS not found.", ephemeral=True); return
            plan = (await read_json(PLANS_FILE)).get(v.get("plan_id"), {})
            embed = Embed(title=f"VPS {vid}", color=0x00FFAA); embed.set_thumbnail(url=BOT_LOGO_URL)
            embed.add_field(name="Plan", value=plan.get('name','-')); embed.add_field(name="OS", value=v.get('os')); embed.add_field(name="Status", value=v.get('status')); embed.add_field(name="SSH", value=v.get('tm_link'))
            view = ManageView(vps_id=vid, owner=interaction.user)
            url_btn = Button(style=nextcord.ButtonStyle.url, label="SSH (tmate)", url=v.get('tm_link'))
            view.add_item(url_btn)
            await interaction2.response.send_message(embed=embed, view=view, ephemeral=True)
    v = VPSSelect(); 
    for child in v.children:
        if isinstance(child, nextcord.ui.Select): child.options = options
    await interaction.response.send_message("Select a VPS to manage:", view=v, ephemeral=True)

@bot.slash_command(name="points", description="Show your points")
async def points_cmd(interaction: Interaction):
    pts = await get_user_points(interaction.user.id); await interaction.response.send_message(f"You have {pts} points.", ephemeral=True)

@bot.slash_command(name="leaderboard", description="Top users by points")
async def leaderboard_cmd(interaction: Interaction):
    users = await read_json(USERS_FILE)
    arr = [(int(uid), int(data.get("points",0))) for uid,data in users.items()]
    arr.sort(key=lambda x:x[1], reverse=True); top = arr[:10]; desc=''
    for i,(uid,pts) in enumerate(top, start=1):
        try: u = await bot.fetch_user(uid); name = u.name
        except Exception: name = str(uid)
        desc += f"{i}. {name} — {pts} pts\n"
    await interaction.response.send_message(embed=Embed(title="Leaderboard", description=desc), ephemeral=True)

@bot.slash_command(name="admin-add", description="Owner: Add admin")
async def admin_add_cmd(interaction: Interaction, user: nextcord.User = SlashOption(description="User to promote")):
    if OWNER_ID and interaction.user.id != OWNER_ID: await interaction.response.send_message("Only owner.", ephemeral=True); return
    await add_admin(user.id); await interaction.response.send_message(f"Added {user} as admin.", ephemeral=True)

@bot.slash_command(name="admin-remove", description="Owner: Remove admin")
async def admin_remove_cmd(interaction: Interaction, user: nextcord.User = SlashOption(description="Admin to remove")):
    if OWNER_ID and interaction.user.id != OWNER_ID: await interaction.response.send_message("Only owner.", ephemeral=True); return
    await remove_admin(user.id); await interaction.response.send_message(f"Removed {user} from admins.", ephemeral=True)

@bot.slash_command(name="admin-list", description="List admins")
async def admin_list(interaction: Interaction):
    admins = await read_json(ADMINS_FILE); cur = admins.get("admins", [])
    if not cur: await interaction.response.send_message("No admins.", ephemeral=True); return
    desc=''; 
    for a in cur:
        try: u = await bot.fetch_user(int(a)); desc += f"- {u.name} (`{a}`)\n"
        except Exception: desc += f"- {a}\n"
    await interaction.response.send_message(embed=Embed(title="Admins", description=desc), ephemeral=True)

@bot.slash_command(name="delete-vps", description="Admin/Owner: Delete a VPS")
async def delete_vps_cmd(interaction: Interaction, vps_id: str = SlashOption(description="VPS ID to delete")):
    if not (await is_admin(interaction.user.id)) and interaction.user.id != OWNER_ID:
        await interaction.response.send_message("Not allowed.", ephemeral=True); return
    vps_all = await read_json(VPS_FILE)
    v = vps_all.get(vps_id)
    if not v: await interaction.response.send_message("VPS not found.", ephemeral=True); return
    cont = v.get("container_name")
    if lxd.available():
        try: lxd.delete(cont)
        except Exception: pass
    del vps_all[vps_id]; await write_json(VPS_FILE, vps_all)
    try: owner = await bot.fetch_user(int(v.get("owner_id"))); await owner.send(f"Your VPS {vps_id} was deleted by admin.")
    except Exception: pass
    await interaction.response.send_message(f"VPS {vps_id} deleted.", ephemeral=True)

@bot.slash_command(name="upgrade-my-vps", description="Upgrade your VPS to another plan (points check)")
async def upgrade_my_vps(interaction: Interaction):
    plans = await read_json(PLANS_FILE); vps_all = await read_json(VPS_FILE)
    user_vps = [v for v in vps_all.values() if int(v.get("owner_id")) == interaction.user.id]
    if not user_vps: await interaction.response.send_message("No VPSes.", ephemeral=True); return
    options = [nextcord.SelectOption(label=f"{v.get('vps_id')} ({v.get('status')})", value=v.get('vps_id')) for v in user_vps]
    class UpgSelect(View):
        @nextcord.ui.select(placeholder="Select your VPS", min_values=1, max_values=1)
        async def sel(self, select: Select, inter: Interaction):
            vps_id = select.values[0]; selected = vps_all.get(vps_id)
            plan_opts = [nextcord.SelectOption(label=f"{p.get('name')} ({p.get('cpu')}c/{p.get('ram')}GB)", value=pid) for pid,p in plans.items()]
            class PlanChoice(View):
                @nextcord.ui.select(placeholder="Select plan", min_values=1, max_values=1)
                async def choose(self, sel2: Select, inter2: Interaction):
                    pid = sel2.values[0]; plan = plans.get(pid)
                    if not plan: await inter2.response.send_message("Plan gone.", ephemeral=True); return
                    current_plan = plans.get(selected.get('plan_id'), {})
                    cost_new = int(plan.get('points_required',0)); cost_old = int(current_plan.get('points_required',0))
                    diff = cost_new - cost_old
                    user_pts = await get_user_points(inter2.user.id)
                    if diff > 0 and user_pts < diff:
                        await inter2.response.send_message(f"Need {diff} more points.", ephemeral=True); return
                    if diff > 0: await add_user_points(inter2.user.id, -diff)
                    selected['plan_id'] = pid; await write_json(VPS_FILE, vps_all)
                    await inter2.response.send_message(f"Upgraded {vps_id} to plan {plan.get('name')}", ephemeral=True)
            pc = PlanChoice(); 
            for c in pc.children:
                if isinstance(c, nextcord.ui.Select): c.options = plan_opts
            await inter.response.send_message("Choose target plan:", view=pc, ephemeral=True)
    view = UpgSelect()
    for c in view.children:
        if isinstance(c, nextcord.ui.Select): c.options = options
    await interaction.response.send_message("Select VPS to upgrade:", view=view, ephemeral=True)

@bot.slash_command(name="development-mode", description="Owner: Toggle development mode (only owner commands allowed)")
async def dev_mode_cmd(interaction: Interaction, mode: str = SlashOption(description="on/off")):
    if OWNER_ID and interaction.user.id != OWNER_ID: await interaction.response.send_message("Only owner.", ephemeral=True); return
    if mode.lower() not in ['on','off']: await interaction.response.send_message("Use on/off.", ephemeral=True); return
    await set_dev_mode(mode.lower()=='on'); await interaction.response.send_message(f"Development mode set to {mode}", ephemeral=True)

@bot.slash_command(name="system-status", description="Owner: View system status (owner only)")
async def system_status_cmd(interaction: Interaction):
    if OWNER_ID and interaction.user.id != OWNER_ID: await interaction.response.send_message("Only owner.", ephemeral=True); return
    vps_all = await read_json(VPS_FILE); total = len(vps_all); running = sum(1 for v in vps_all.values() if v.get('status')=='running'); stopped = sum(1 for v in vps_all.values() if v.get('status')=='stopped'); suspended = sum(1 for v in vps_all.values() if v.get('status')=='suspended')
    cpu_total = 'N/A'; ram_total='N/A'; disk_total='N/A'
    try:
        if lxd.available():
            cpu_total = 'Host CPU info available'; ram_total='Host RAM info available'; disk_total='Host Disk info available'
    except Exception:
        pass
    desc = f"Total VPS: {total}\nRunning: {running}\nStopped: {stopped}\nSuspended: {suspended}\nCPU: {cpu_total}\nRAM: {ram_total}\nDisk: {disk_total}"
    lines = "\n\n"
    for vid,v in vps_all.items():
        lines += f"{vid} | Owner: {v.get('owner_id')} | Status: {v.get('status')} | Plan: {v.get('plan_id')}\n"
    await interaction.response.send_message(embed=Embed(title="System Status", description=desc+lines), ephemeral=True)

@bot.slash_command(name="announce", description="Owner: Announce DM to all VPS owners")
async def announce_cmd(interaction: Interaction, message: str = SlashOption(description="Announcement message")):
    if OWNER_ID and interaction.user.id != OWNER_ID: await interaction.response.send_message("Only owner.", ephemeral=True); return
    vps_all = await read_json(VPS_FILE)
    owners = set(int(v.get('owner_id')) for v in vps_all.values())
    sent=0; failed=0
    for o in owners:
        try:
            u = await bot.fetch_user(o); await u.send(message); sent+=1
        except Exception: failed+=1
    await interaction.response.send_message(f"Announce sent to {sent} users, {failed} failed.", ephemeral=True)

@bot.slash_command(name="non-purge", description="Admin/Owner: Mark VPS safe from purge")
async def non_purge_cmd(interaction: Interaction, vps_id: str = SlashOption(description="VPS ID to mark safe")):
    if not (await is_admin(interaction.user.id)) and interaction.user.id != OWNER_ID: await interaction.response.send_message("Not allowed.", ephemeral=True); return
    await add_purge_safe(vps_id); await interaction.response.send_message(f"{vps_id} marked safe.", ephemeral=True)

@bot.slash_command(name="purge-remove", description="Admin/Owner: Remove VPS from purge-safe list")
async def purge_remove_cmd(interaction: Interaction, vps_id: str = SlashOption(description="VPS ID to remove from safe list")):
    if not (await is_admin(interaction.user.id)) and interaction.user.id != OWNER_ID: await interaction.response.send_message("Not allowed.", ephemeral=True); return
    await remove_purge_safe(vps_id); await interaction.response.send_message(f"{vps_id} removed from safe list.", ephemeral=True)

@bot.slash_command(name="purge", description="Owner: Purge all non-safe VPSes (owner only)")
async def purge_cmd(interaction: Interaction):
    if OWNER_ID and interaction.user.id != OWNER_ID: await interaction.response.send_message("Only owner.", ephemeral=True); return
    vps_all = await read_json(VPS_FILE); safe = await get_purge_safe_list(); deleted=[]; kept=[]
    for vid,v in list(vps_all.items()):
        if vid in safe:
            kept.append(vid)
        else:
            cont = v.get("container_name")
            if lxd.available():
                try: lxd.delete(cont)
                except Exception: pass
            del vps_all[vid]; deleted.append(vid)
    # reset safe list after purge
    meta = await read_json(META_FILE)
    meta["purge_safe"] = []
    await write_json(VPS_FILE, vps_all); await write_json(META_FILE, meta)
    await interaction.response.send_message(f"Purge complete. Deleted: {len(deleted)}. Kept: {len(kept)}.", ephemeral=True)

# Error handler
@bot.event
async def on_application_command_error(interaction: Interaction, error):
    try: await interaction.response.send_message(f"Error: {str(error)}", ephemeral=True)
    except Exception: pass

# Entry point
if __name__ == '__main__':
    if not BOT_TOKEN or BOT_TOKEN == 'YOUR_TOKEN_HERE':
        print('Please set BOT_TOKEN in .env and OWNER_ID (optional).')
    else:
        bot.run(BOT_TOKEN)
